{"ast":null,"code":"import { AdditiveBlending, Color, MeshBasicMaterial, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\r\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\r\n * mip map chain of bloom textures and blurs them with different radii. Because\r\n * of the weighted combination of mips, and because larger blurs are done on\r\n * higher mips, this effect provides good quality and performance.\r\n *\r\n * Reference:\r\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\nclass UnrealBloomPass extends Pass {\n  constructor(resolution, strength, radius, threshold) {\n    super();\n    this.strength = strength !== undefined ? strength : 1;\n    this.radius = radius;\n    this.threshold = threshold;\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n\n    // create color only once here, reuse it later inside the render function\n    this.clearColor = new Color(0, 0, 0);\n\n    // render targets\n    this.renderTargetsHorizontal = [];\n    this.renderTargetsVertical = [];\n    this.nMips = 5;\n    let resx = Math.round(this.resolution.x / 2);\n    let resy = Math.round(this.resolution.y / 2);\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy);\n    this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n    this.renderTargetBright.texture.generateMipmaps = false;\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy);\n      renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n      renderTargetHorizonal.texture.generateMipmaps = false;\n      this.renderTargetsHorizontal.push(renderTargetHorizonal);\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy);\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n      this.renderTargetsVertical.push(renderTargetVertical);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // luminosity high pass material\n\n    const highPassShader = LuminosityHighPassShader;\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    this.highPassUniforms['luminosityThreshold'].value = threshold;\n    this.highPassUniforms['smoothWidth'].value = 0.01;\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {}\n    });\n\n    // Gaussian Blur Materials\n    this.separableBlurMaterials = [];\n    const kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(this.resolution.x / 2);\n    resy = Math.round(this.resolution.y / 2);\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // Composite material\n    this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n    this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n    this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n    this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n    this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n    this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n    this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n    this.compositeMaterial.needsUpdate = true;\n    const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n    this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n    this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n\n    // copy material\n\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms['opacity'].value = 1.0;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.basic = new MeshBasicMaterial();\n    this.fsQuad = new FullScreenQuad(null);\n  }\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n    this.renderTargetBright.dispose();\n\n    //\n\n    for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n      this.separableBlurMaterials[i].dispose();\n    }\n    this.compositeMaterial.dispose();\n    this.materialCopy.dispose();\n    this.basic.dispose();\n\n    //\n\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    let resx = Math.round(width / 2);\n    let resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false);\n\n    // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    // 1. Extract Bright Areas\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n\n    // 2. Blur All the mips progressively\n\n    let inputRenderTarget = this.renderTargetBright;\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    }\n\n    // Composite All the mips\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n\n    // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    }\n\n    // Restore renderer settings\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  }\n  getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        'KERNEL_RADIUS': kernelRadius,\n        'SIGMA': kernelRadius\n      },\n      uniforms: {\n        'colorTexture': {\n          value: null\n        },\n        'texSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'direction': {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n    });\n  }\n  getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        'NUM_MIPS': nMips\n      },\n      uniforms: {\n        'blurTexture1': {\n          value: null\n        },\n        'blurTexture2': {\n          value: null\n        },\n        'blurTexture3': {\n          value: null\n        },\n        'blurTexture4': {\n          value: null\n        },\n        'blurTexture5': {\n          value: null\n        },\n        'bloomStrength': {\n          value: 1.0\n        },\n        'bloomFactors': {\n          value: null\n        },\n        'bloomTintColors': {\n          value: null\n        },\n        'bloomRadius': {\n          value: 0.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n    });\n  }\n}\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"names":["AdditiveBlending","Color","MeshBasicMaterial","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","LuminosityHighPassShader","UnrealBloomPass","constructor","resolution","strength","radius","threshold","undefined","x","y","clearColor","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius"],"sources":["F:/Portfolio/3D-portfolio/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import {\r\n\tAdditiveBlending,\r\n\tColor,\r\n\tMeshBasicMaterial,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tVector2,\r\n\tVector3,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\r\n\r\n/**\r\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\r\n * mip map chain of bloom textures and blurs them with different radii. Because\r\n * of the weighted combination of mips, and because larger blurs are done on\r\n * higher mips, this effect provides good quality and performance.\r\n *\r\n * Reference:\r\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\r\nclass UnrealBloomPass extends Pass {\r\n\r\n\tconstructor( resolution, strength, radius, threshold ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\r\n\t\tthis.radius = radius;\r\n\t\tthis.threshold = threshold;\r\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\r\n\r\n\t\t// create color only once here, reuse it later inside the render function\r\n\t\tthis.clearColor = new Color( 0, 0, 0 );\r\n\r\n\t\t// render targets\r\n\t\tthis.renderTargetsHorizontal = [];\r\n\t\tthis.renderTargetsVertical = [];\r\n\t\tthis.nMips = 5;\r\n\t\tlet resx = Math.round( this.resolution.x / 2 );\r\n\t\tlet resy = Math.round( this.resolution.y / 2 );\r\n\r\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy );\r\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\r\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tconst renderTargetHorizonal = new WebGLRenderTarget( resx, resy );\r\n\r\n\t\t\trenderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\r\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\r\n\r\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\r\n\r\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy );\r\n\r\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\r\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\r\n\r\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\r\n\r\n\t\t\tresx = Math.round( resx / 2 );\r\n\r\n\t\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\t}\r\n\r\n\t\t// luminosity high pass material\r\n\r\n\t\tconst highPassShader = LuminosityHighPassShader;\r\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\r\n\r\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\r\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\r\n\r\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\r\n\t\t\tuniforms: this.highPassUniforms,\r\n\t\t\tvertexShader: highPassShader.vertexShader,\r\n\t\t\tfragmentShader: highPassShader.fragmentShader,\r\n\t\t\tdefines: {}\r\n\t\t} );\r\n\r\n\t\t// Gaussian Blur Materials\r\n\t\tthis.separableBlurMaterials = [];\r\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\r\n\t\tresx = Math.round( this.resolution.x / 2 );\r\n\t\tresy = Math.round( this.resolution.y / 2 );\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\r\n\r\n\t\t\tresx = Math.round( resx / 2 );\r\n\r\n\t\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\t}\r\n\r\n\t\t// Composite material\r\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\r\n\t\tthis.compositeMaterial.needsUpdate = true;\r\n\r\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\r\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\r\n\r\n\t\t// copy material\r\n\r\n\t\tconst copyShader = CopyShader;\r\n\r\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\r\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\r\n\r\n\t\tthis.materialCopy = new ShaderMaterial( {\r\n\t\t\tuniforms: this.copyUniforms,\r\n\t\t\tvertexShader: copyShader.vertexShader,\r\n\t\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\t\tblending: AdditiveBlending,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t\tthis.enabled = true;\r\n\t\tthis.needsSwap = false;\r\n\r\n\t\tthis._oldClearColor = new Color();\r\n\t\tthis.oldClearAlpha = 1;\r\n\r\n\t\tthis.basic = new MeshBasicMaterial();\r\n\r\n\t\tthis.fsQuad = new FullScreenQuad( null );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\r\n\r\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\r\n\r\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTargetBright.dispose();\r\n\r\n\t\t//\r\n\r\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.compositeMaterial.dispose();\r\n\t\tthis.materialCopy.dispose();\r\n\t\tthis.basic.dispose();\r\n\r\n\t\t//\r\n\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n\r\n\tsetSize( width, height ) {\r\n\r\n\t\tlet resx = Math.round( width / 2 );\r\n\t\tlet resy = Math.round( height / 2 );\r\n\r\n\t\tthis.renderTargetBright.setSize( resx, resy );\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\r\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\r\n\r\n\t\t\tresx = Math.round( resx / 2 );\r\n\t\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\r\n\r\n\t\trenderer.getClearColor( this._oldClearColor );\r\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\r\n\t\tconst oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\trenderer.setClearColor( this.clearColor, 0 );\r\n\r\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\r\n\r\n\t\t// Render input to screen\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\tthis.fsQuad.material = this.basic;\r\n\t\t\tthis.basic.map = readBuffer.texture;\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t\t// 1. Extract Bright Areas\r\n\r\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\r\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\r\n\r\n\t\trenderer.setRenderTarget( this.renderTargetBright );\r\n\t\trenderer.clear();\r\n\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t// 2. Blur All the mips progressively\r\n\r\n\t\tlet inputRenderTarget = this.renderTargetBright;\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// Composite All the mips\r\n\r\n\t\tthis.fsQuad.material = this.compositeMaterial;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\r\n\r\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\r\n\t\trenderer.clear();\r\n\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t// Blend it additively over the input texture\r\n\r\n\t\tthis.fsQuad.material = this.materialCopy;\r\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\r\n\r\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.setRenderTarget( readBuffer );\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t\t// Restore renderer settings\r\n\r\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t}\r\n\r\n\tgetSeperableBlurMaterial( kernelRadius ) {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t'KERNEL_RADIUS': kernelRadius,\r\n\t\t\t\t'SIGMA': kernelRadius\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'colorTexture': { value: null },\r\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t`#include <common>\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform sampler2D colorTexture;\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec2 direction;\r\n\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\r\n\t\t\t\t}\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\r\n\t\t\t\t\t\tfloat x = float(i);\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tgetCompositeMaterial( nMips ) {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t'NUM_MIPS': nMips\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'blurTexture1': { value: null },\r\n\t\t\t\t'blurTexture2': { value: null },\r\n\t\t\t\t'blurTexture3': { value: null },\r\n\t\t\t\t'blurTexture4': { value: null },\r\n\t\t\t\t'blurTexture5': { value: null },\r\n\t\t\t\t'bloomStrength': { value: 1.0 },\r\n\t\t\t\t'bloomFactors': { value: null },\r\n\t\t\t\t'bloomTintColors': { value: null },\r\n\t\t\t\t'bloomRadius': { value: 0.0 }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\t\t\t\tuniform sampler2D blurTexture1;\r\n\t\t\t\tuniform sampler2D blurTexture2;\r\n\t\t\t\tuniform sampler2D blurTexture3;\r\n\t\t\t\tuniform sampler2D blurTexture4;\r\n\t\t\t\tuniform sampler2D blurTexture5;\r\n\t\t\t\tuniform float bloomStrength;\r\n\t\t\t\tuniform float bloomRadius;\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\r\n\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\r\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\r\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\r\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\r\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\r\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\r\n\r\nexport { UnrealBloomPass };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}