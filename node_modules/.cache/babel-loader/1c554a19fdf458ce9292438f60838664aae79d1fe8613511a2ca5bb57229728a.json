{"ast":null,"code":"import { Matrix4, Vector2 } from 'three';\n\n/**\r\n * References:\r\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\r\n * https://learnopengl.com/Advanced-Lighting/SSAO\r\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\r\n */\n\nconst SSAOShader = {\n  defines: {\n    'PERSPECTIVE_CAMERA': 1,\n    'KERNEL_SIZE': 32\n  },\n  uniforms: {\n    'tDiffuse': {\n      value: null\n    },\n    'tNormal': {\n      value: null\n    },\n    'tDepth': {\n      value: null\n    },\n    'tNoise': {\n      value: null\n    },\n    'kernel': {\n      value: null\n    },\n    'cameraNear': {\n      value: null\n    },\n    'cameraFar': {\n      value: null\n    },\n    'resolution': {\n      value: new Vector2()\n    },\n    'cameraProjectionMatrix': {\n      value: new Matrix4()\n    },\n    'cameraInverseProjectionMatrix': {\n      value: new Matrix4()\n    },\n    'kernelRadius': {\n      value: 8\n    },\n    'minDistance': {\n      value: 0.005\n    },\n    'maxDistance': {\n      value: 0.05\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\n\t\tuniform vec3 kernel[ KERNEL_SIZE ];\n\n\t\tuniform vec2 resolution;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float kernelRadius;\n\t\tuniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\tuniform float maxDistance; // avoid the influence of fragments which are too far away\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t}\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec2 screenPosition ) {\n\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\n\t\t\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\t\t\tvec3 viewNormal = getViewNormal( vUv );\n\n\t\t\tvec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\t\t\tvec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\t\t\tvec3 bitangent = cross( viewNormal, tangent );\n\t\t\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n\t\t float occlusion = 0.0;\n\n\t\t for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n\t\t\t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n\t\t\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n\t\t\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n\t\t\t\tsamplePointNDC /= samplePointNDC.w;\n\n\t\t\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n\t\t\t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n\t\t\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n\t\t\t\tfloat delta = sampleDepth - realDepth;\n\n\t\t\t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n\t\t\t\t\tocclusion += 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n\t\t}`\n};\nconst SSAODepthShader = {\n  defines: {\n    'PERSPECTIVE_CAMERA': 1\n  },\n  uniforms: {\n    'tDepth': {\n      value: null\n    },\n    'cameraNear': {\n      value: null\n    },\n    'cameraFar': {\n      value: null\n    }\n  },\n  vertexShader: `varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: `uniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}`\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    'tDiffuse': {\n      value: null\n    },\n    'resolution': {\n      value: new Vector2()\n    }\n  },\n  vertexShader: `varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: `uniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\t\t\tfloat result = 0.0;\n\n\t\t\tfor ( int i = - 2; i <= 2; i ++ ) {\n\n\t\t\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n\t\t\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n\t\t}`\n};\nexport { SSAOShader, SSAODepthShader, SSAOBlurShader };","map":{"version":3,"names":["Matrix4","Vector2","SSAOShader","defines","uniforms","value","vertexShader","fragmentShader","SSAODepthShader","SSAOBlurShader"],"sources":["F:/Portfolio/3D-portfolio/node_modules/three/examples/jsm/shaders/SSAOShader.js"],"sourcesContent":["import {\r\n\tMatrix4,\r\n\tVector2\r\n} from 'three';\r\n\r\n/**\r\n * References:\r\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\r\n * https://learnopengl.com/Advanced-Lighting/SSAO\r\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\r\n */\r\n\r\nconst SSAOShader = {\r\n\r\n\tdefines: {\r\n\t\t'PERSPECTIVE_CAMERA': 1,\r\n\t\t'KERNEL_SIZE': 32\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'tNormal': { value: null },\r\n\t\t'tDepth': { value: null },\r\n\t\t'tNoise': { value: null },\r\n\t\t'kernel': { value: null },\r\n\t\t'cameraNear': { value: null },\r\n\t\t'cameraFar': { value: null },\r\n\t\t'resolution': { value: new Vector2() },\r\n\t\t'cameraProjectionMatrix': { value: new Matrix4() },\r\n\t\t'cameraInverseProjectionMatrix': { value: new Matrix4() },\r\n\t\t'kernelRadius': { value: 8 },\r\n\t\t'minDistance': { value: 0.005 },\r\n\t\t'maxDistance': { value: 0.05 },\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform sampler2D tNormal;\r\n\t\tuniform sampler2D tDepth;\r\n\t\tuniform sampler2D tNoise;\r\n\r\n\t\tuniform vec3 kernel[ KERNEL_SIZE ];\r\n\r\n\t\tuniform vec2 resolution;\r\n\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tuniform mat4 cameraProjectionMatrix;\r\n\t\tuniform mat4 cameraInverseProjectionMatrix;\r\n\r\n\t\tuniform float kernelRadius;\r\n\t\tuniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\r\n\t\tuniform float maxDistance; // avoid the influence of fragments which are too far away\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\t#include <packing>\r\n\r\n\t\tfloat getDepth( const in vec2 screenPosition ) {\r\n\r\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\r\n\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\r\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\r\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\r\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t}\r\n\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\r\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t}\r\n\r\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\r\n\r\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\r\n\r\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\r\n\r\n\t\t\tclipPosition *= clipW; // unprojection.\r\n\r\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 getViewNormal( const in vec2 screenPosition ) {\r\n\r\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tfloat depth = getDepth( vUv );\r\n\t\t\tfloat viewZ = getViewZ( depth );\r\n\r\n\t\t\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\r\n\t\t\tvec3 viewNormal = getViewNormal( vUv );\r\n\r\n\t\t\tvec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\r\n\t\t\tvec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );\r\n\r\n\t\t\t// compute matrix used to reorient a kernel vector\r\n\r\n\t\t\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\r\n\t\t\tvec3 bitangent = cross( viewNormal, tangent );\r\n\t\t\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\r\n\r\n\t\t float occlusion = 0.0;\r\n\r\n\t\t for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\r\n\r\n\t\t\t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\r\n\t\t\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\r\n\r\n\t\t\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\r\n\t\t\t\tsamplePointNDC /= samplePointNDC.w;\r\n\r\n\t\t\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\r\n\r\n\t\t\t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\r\n\t\t\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\r\n\t\t\t\tfloat delta = sampleDepth - realDepth;\r\n\r\n\t\t\t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\r\n\r\n\t\t\t\t\tocclusion += 1.0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\r\n\r\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nconst SSAODepthShader = {\r\n\r\n\tdefines: {\r\n\t\t'PERSPECTIVE_CAMERA': 1\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDepth': { value: null },\r\n\t\t'cameraNear': { value: null },\r\n\t\t'cameraFar': { value: null },\r\n\r\n\t},\r\n\r\n\tvertexShader:\r\n\r\n\t\t`varying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader:\r\n\r\n\t\t`uniform sampler2D tDepth;\r\n\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\t#include <packing>\r\n\r\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\r\n\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\r\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\r\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\r\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tfloat depth = getLinearDepth( vUv );\r\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nconst SSAOBlurShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'resolution': { value: new Vector2() }\r\n\r\n\t},\r\n\r\n\tvertexShader:\r\n\r\n\t\t`varying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader:\r\n\r\n\t\t`uniform sampler2D tDiffuse;\r\n\r\n\t\tuniform vec2 resolution;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\r\n\t\t\tfloat result = 0.0;\r\n\r\n\t\t\tfor ( int i = - 2; i <= 2; i ++ ) {\r\n\r\n\t\t\t\tfor ( int j = - 2; j <= 2; j ++ ) {\r\n\r\n\t\t\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\r\n\t\t\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { SSAOShader, SSAODepthShader, SSAOBlurShader };\r\n"],"mappings":"AAAA,SACCA,OAAO,EACPC,OAAO,QACD,OAAO;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,UAAU,GAAG;EAElBC,OAAO,EAAE;IACR,oBAAoB,EAAE,CAAC;IACvB,aAAa,EAAE;EAChB,CAAC;EAEDC,QAAQ,EAAE;IAET,UAAU,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IAC3B,SAAS,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAC1B,QAAQ,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IACzB,QAAQ,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IACzB,QAAQ,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IACzB,YAAY,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAC7B,WAAW,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAC5B,YAAY,EAAE;MAAEA,KAAK,EAAE,IAAIJ,OAAO,CAAC;IAAE,CAAC;IACtC,wBAAwB,EAAE;MAAEI,KAAK,EAAE,IAAIL,OAAO,CAAC;IAAE,CAAC;IAClD,+BAA+B,EAAE;MAAEK,KAAK,EAAE,IAAIL,OAAO,CAAC;IAAE,CAAC;IACzD,cAAc,EAAE;MAAEK,KAAK,EAAE;IAAE,CAAC;IAC5B,aAAa,EAAE;MAAEA,KAAK,EAAE;IAAM,CAAC;IAC/B,aAAa,EAAE;MAAEA,KAAK,EAAE;IAAK;EAE9B,CAAC;EAEDC,YAAY,EAAE,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHC,cAAc,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC;AAED,MAAMC,eAAe,GAAG;EAEvBL,OAAO,EAAE;IACR,oBAAoB,EAAE;EACvB,CAAC;EAEDC,QAAQ,EAAE;IAET,QAAQ,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IACzB,YAAY,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAC7B,WAAW,EAAE;MAAEA,KAAK,EAAE;IAAK;EAE5B,CAAC;EAEDC,YAAY,EAEX;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHC,cAAc,EAEb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC;AAED,MAAME,cAAc,GAAG;EAEtBL,QAAQ,EAAE;IAET,UAAU,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IAC3B,YAAY,EAAE;MAAEA,KAAK,EAAE,IAAIJ,OAAO,CAAC;IAAE;EAEtC,CAAC;EAEDK,YAAY,EAEX;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHC,cAAc,EAEb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC;AAED,SAASL,UAAU,EAAEM,eAAe,EAAEC,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}