"use strict";(self.webpackChunkmy_3d_portfolio=self.webpackChunkmy_3d_portfolio||[]).push([[314],{2314:(o,e,t)=>{t.r(e),t.d(e,{default:()=>r});var i=t(6540),n=t(5880);const r=o=>{let{initialX:e=1.4,color:t={r:1,g:.8,b:.4},glowRadiusX:r=.35,glowRadiusY:a=.2,intensity:l=2,opacity:u=0,wiggleAmount:s=70,verticalWiggleAmount:c=30,fadeDuration:d=3,wiggleSpeed:g=5,lightDirection:f=1.1}=o;const w=(0,i.useRef)(null);return(0,i.useEffect)((()=>{const o=w.current,i=o.getContext("webgl");if(!i)return void console.error("WebGL not supported");const s=()=>{o.width=window.innerWidth,o.height=window.innerHeight,i.viewport(0,0,o.width,o.height)};s(),window.addEventListener("resize",s);const c="\n      precision mediump float;\n      uniform vec2 u_resolution;\n      uniform vec2 u_lightPos;\n      uniform float u_glowRadiusX;\n      uniform float u_glowRadiusY;\n      uniform float u_intensity;\n      uniform float u_opacity;\n      \n      void main() {\n        vec2 uv = gl_FragCoord.xy / u_resolution;\n        vec2 lightDir = (gl_FragCoord.xy - u_lightPos) / vec2(u_glowRadiusX, u_glowRadiusY); // Normalize ellipse shape\n        float dist = length(lightDir); \n\n        // Soft Glow Effect\n        float glow = smoothstep(0.9, 0.2, dist);\n        glow *= exp(-dist) * u_intensity;\n\n        // Elliptical Glow Spread\n        float spread = exp(-pow(dist, 2.0));\n        float finalGlow = mix(spread, glow, 0.7); \n\n        // Apply Color and Opacity\n        vec3 color = vec3(".concat(t.r,", ").concat(t.g,", ").concat(t.b,") * finalGlow;\n        gl_FragColor = vec4(color, finalGlow * u_opacity);\n      }\n    "),g=(o,e)=>{const t=i.createShader(o);return i.shaderSource(t,e),i.compileShader(t),i.getShaderParameter(t,i.COMPILE_STATUS)?t:(console.error(i.getShaderInfoLog(t)),null)},m=g(i.VERTEX_SHADER,"\n      attribute vec2 position;\n      void main() {\n        gl_Position = vec4(position, 0.0, 1.0);\n      }\n    "),h=g(i.FRAGMENT_SHADER,c),p=i.createProgram();if(i.attachShader(p,m),i.attachShader(p,h),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return void console.error(i.getProgramInfoLog(p));i.useProgram(p);const _=new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),y=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,y),i.bufferData(i.ARRAY_BUFFER,_,i.STATIC_DRAW);const A=i.getAttribLocation(p,"position");i.enableVertexAttribArray(A),i.vertexAttribPointer(A,2,i.FLOAT,!1,0,0);const v=i.getUniformLocation(p,"u_resolution"),R=i.getUniformLocation(p,"u_lightPos"),S=i.getUniformLocation(p,"u_glowRadiusX"),L=i.getUniformLocation(p,"u_glowRadiusY"),E=i.getUniformLocation(p,"u_intensity"),b=i.getUniformLocation(p,"u_opacity"),P={x:window.innerWidth*e,y:.55*window.innerHeight,radiusX:window.innerWidth*r,radiusY:window.innerHeight*a,intensity:l,opacity:u},x=n.Ay.timeline({repeat:-1,yoyo:!0});x.to(P,{x:window.innerWidth*f,duration:4.5,ease:"power2.out"}),x.to(P,{opacity:1,duration:d,ease:"power2.out"});const F=()=>{i.uniform2f(v,o.width,o.height),i.uniform2f(R,P.x,P.y),i.uniform1f(S,P.radiusX),i.uniform1f(L,P.radiusY),i.uniform1f(E,P.intensity),i.uniform1f(b,P.opacity),i.drawArrays(i.TRIANGLES,0,6),requestAnimationFrame(F)};return setTimeout((()=>{F()}),500),()=>{window.removeEventListener("resize",s),i.deleteProgram(p)}}),[e,t,r,a,l,u,s,c,d,g,f]),i.createElement("canvas",{ref:w,className:"shader-background"})}}}]);
//# sourceMappingURL=314.e527c7548a4277f0aa00.js.map