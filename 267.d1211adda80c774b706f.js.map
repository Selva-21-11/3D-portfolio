{"version":3,"file":"267.d1211adda80c774b706f.js","mappings":"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","sources":["webpack://my-3d-portfolio/./src/components/TitleBG.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport * as THREE from 'three';\nimport { gsap } from 'gsap';\nimport { throttle } from 'lodash';\n\nconst TitleBG = () => {\n  const sceneRef = useRef(null);\n  const rendererRef = useRef(null);\n  const cameraRef = useRef(null);\n  const bigSphereRef = useRef(null);\n  const smallSphereRef = useRef(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const scene = new THREE.Scene();\n    const aspect = window.innerWidth / window.innerHeight;\n    const camera = new THREE.OrthographicCamera(\n      -2 * aspect, 2 * aspect, 2, -2, 0.1, 1000\n    );\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      preserveDrawingBuffer: true,\n      alpha: true,  // Set alpha to true for transparency\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setClearColor(0x000000, 0); // Set the background to transparent (alpha = 0)\n    renderer.outputEncoding = THREE.LinearSRGBColorSpace;\n    renderer.physicallyCorrectLights = true;\n    document.getElementById('hero').appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n    cameraRef.current = camera;\n    sceneRef.current = scene;\n    camera.position.z = 5;\n\n    // Set up the loading manager\n    const loadingManager = new THREE.LoadingManager();\n    loadingManager.onStart = () => console.log(\"Loading started...\");\n    loadingManager.onLoad = () => {\n      console.log(\"Loading complete!\");\n      setIsLoading(false);\n\n      // Trigger popup animation after loading\n      gsap.fromTo(bigSphereRef.current.scale, { x: 0, y: 0, z: 0 }, { x: 1, y: 1, z: 1, duration: 1, ease: 'power3.out' });\n      gsap.fromTo(smallSphereRef.current.scale, { x: 0, y: 0, z: 0 }, { x: 1, y: 1, z: 1, duration: 1, ease: 'power3.out' });\n    };\n\n    // Load MatCap textures\n    const textureLoader = new THREE.TextureLoader(loadingManager);\n    const matCapTextureBig = textureLoader.load('./assets/mattext.webp'); // Replace with your matcap texture\n    const matCapTextureSmall = textureLoader.load('./assets/mattext.webp'); // Replace with your matcap texture\n\n    // Set texture wrapping\n    matCapTextureBig.wrapS = matCapTextureBig.wrapT = THREE.ClampToEdgeWrapping;\n    matCapTextureSmall.wrapS = matCapTextureSmall.wrapT = THREE.ClampToEdgeWrapping;\n\n    const shaderMaterialBig = new THREE.ShaderMaterial({\n      uniforms: {\n        tMatCap: { type: 't', value: matCapTextureBig },\n      },\n      vertexShader: `\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n    \n        void main() {\n          vNormal = normalize(normalMatrix * normal);\n          vPosition = position;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform sampler2D tMatCap;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n    \n        void main() {\n          vec3 matCapColor = texture2D(tMatCap, vec2(vNormal.x * 0.5 + 0.5, vNormal.y * 0.5 + 0.5)).rgb;\n          gl_FragColor = vec4(matCapColor, 1.0);\n        }\n      `,\n    });\n    \n    // Same change for the small sphere material:\n    const shaderMaterialSmall = new THREE.ShaderMaterial({\n      uniforms: {\n        tMatCap: { type: 't', value: matCapTextureSmall },\n      },\n      vertexShader: `\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n    \n        void main() {\n          vNormal = normalize(normalMatrix * normal);\n          vPosition = position;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform sampler2D tMatCap;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n    \n        void main() {\n          vec3 matCapColor = texture2D(tMatCap, vec2(vNormal.x * 0.5 + 0.5, vNormal.y * 0.5 + 0.5)).rgb;\n          gl_FragColor = vec4(matCapColor, 1.0);\n        }\n      `,\n    });\n\n    // Create sphere geometries\n    const bigSphereGeometry = new THREE.SphereGeometry(1.5, 32, 32);\n    const smallSphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);\n\n    // Create meshes with ShaderMaterial\n    const bigSphere = new THREE.Mesh(bigSphereGeometry, shaderMaterialBig);\n    const smallSphere = new THREE.Mesh(smallSphereGeometry, shaderMaterialSmall);\n\n    // Group the spheres for easier management\n    const sphereGroup = new THREE.Group();\n    sphereGroup.add(bigSphere);\n    sphereGroup.add(smallSphere);\n    scene.add(sphereGroup);\n\n    bigSphereRef.current = bigSphere;\n    smallSphereRef.current = smallSphere;\n\n    const handleMouseMove = throttle((event) => {\n      // Get mouse position relative to the center of the window\n      const mouseXPosition = (event.clientX / window.innerWidth) * 2 - 1;  // Normalized -1 to 1\n      const mouseYPosition = (event.clientY / window.innerHeight) * 2 - 1;  // Normalized -1 to 1\n    \n      // Set a radius for the circular movement\n      const radius = 1.6;\n    \n      // Calculate the angle for the small sphere's position\n      // Use the mouse position to compute a circular path angle (not just position)\n      const angle = Math.atan2(mouseYPosition, mouseXPosition);  // Get the angle between mouse and center\n      \n      // Now map this angle to a circular path\n      const targetX = radius * Math.cos(angle);  // Calculate X position along the circular path\n      const targetY = radius * Math.sin(angle);  // Calculate Y position along the circular path\n    \n      // Update small sphere's position based on the calculated target\n      gsap.to(smallSphere.position, { x: targetX, y: targetY, z: -1, duration: 0.5, ease: 'power3.out' });\n    \n      // Optional: Move the camera to give the feeling of interactivity\n      const parallaxX = mouseXPosition * 0.1;\n      const parallaxY = mouseYPosition * 0.1;\n      gsap.to(camera.position, { x: parallaxX, y: parallaxY, z: 5, duration: 0.6, ease: 'power3.out' });\n    }, 60);  // Reduced throttle delay for better responsiveness\n    \n\n    window.addEventListener('mousemove', handleMouseMove);\n\n    // Animation loop\n    const animate = () => {\n      if (!isLoading) {\n        renderer.render(scene, camera);\n      }\n      requestAnimationFrame(animate);\n    };\n    animate();\n\n    // Resize handling\n    const onWindowResize = () => {\n      const aspect = window.innerWidth / window.innerHeight;\n      camera.left = -2 * aspect;\n      camera.right = 2 * aspect;\n      camera.top = 2;\n      camera.bottom = -2;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n    window.addEventListener('resize', onWindowResize);\n\n    // Cleanup function (unload)\n    const unload = () => {\n      window.removeEventListener('resize', onWindowResize);\n      window.removeEventListener('mousemove', handleMouseMove);\n\n      // Dispose of materials, geometries, and textures\n      matCapTextureBig.dispose();\n      matCapTextureSmall.dispose();\n      bigSphereGeometry.dispose();\n      smallSphereGeometry.dispose();\n      bigSphere.material.dispose();\n      smallSphere.material.dispose();\n\n      // Clear scene\n      scene.clear();\n      renderer.dispose();\n    };\n\n    // Call unload function on component unmount\n    return () => {\n      unload();\n    };\n  }, [isLoading]);\n\n  return (\n    <div>\n      {isLoading && (\n        <div className=\"loading-screen\">\n          <h3>Loading...</h3>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default TitleBG;\n"],"names":["TitleBG","sceneRef","useRef","rendererRef","cameraRef","bigSphereRef","smallSphereRef","isLoading","setIsLoading","useState","useEffect","scene","THREE","aspect","window","innerWidth","innerHeight","camera","renderer","antialias","preserveDrawingBuffer","alpha","setSize","setClearColor","outputEncoding","physicallyCorrectLights","document","getElementById","appendChild","domElement","current","position","z","loadingManager","onStart","console","log","onLoad","gsap","fromTo","scale","x","y","duration","ease","textureLoader","matCapTextureBig","load","matCapTextureSmall","wrapS","wrapT","shaderMaterialBig","uniforms","tMatCap","type","value","vertexShader","fragmentShader","shaderMaterialSmall","bigSphereGeometry","smallSphereGeometry","bigSphere","smallSphere","sphereGroup","add","handleMouseMove","throttle","event","mouseXPosition","clientX","mouseYPosition","clientY","angle","Math","atan2","targetX","cos","targetY","sin","to","parallaxX","parallaxY","addEventListener","animate","render","requestAnimationFrame","onWindowResize","left","right","top","bottom","updateProjectionMatrix","removeEventListener","dispose","material","clear","React","className"],"sourceRoot":""}