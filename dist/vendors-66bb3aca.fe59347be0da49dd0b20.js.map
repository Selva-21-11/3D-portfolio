{"version":3,"file":"vendors-66bb3aca.fe59347be0da49dd0b20.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animate/single-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/inertia.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-none.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LazyContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/PresenceContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs"],"sourcesContent":["import { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\r\n\r\nfunction animateSingleValue(value, keyframes, options) {\r\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\r\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\r\n    return motionValue$1.animation;\r\n}\r\n\r\nexport { animateSingleValue };\r\n","import { complex } from '../../value/types/complex/index.mjs';\r\n\r\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * ✅: 100, \"100px\", \"#fff\"\r\n * ❌: \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nconst isAnimatable = (value, name) => {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (name === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nexport { isAnimatable };\r\n","import { time } from '../../frameloop/sync-time.mjs';\r\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { canAnimate } from './utils/can-animate.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\n/**\r\n * Maximum time allowed between an animation being created and it being\r\n * resolved for us to use the latter as the start time.\r\n *\r\n * This is to ensure that while we prefer to \"start\" an animation as soon\r\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\r\n * between these two moments.\r\n */\r\nconst MAX_RESOLVE_DELAY = 40;\r\nclass BaseAnimation {\r\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\r\n        // Track whether the animation has been stopped. Stopped animations won't restart.\r\n        this.isStopped = false;\r\n        this.hasAttemptedResolve = false;\r\n        this.createdAt = time.now();\r\n        this.options = {\r\n            autoplay,\r\n            delay,\r\n            type,\r\n            repeat,\r\n            repeatDelay,\r\n            repeatType,\r\n            ...options,\r\n        };\r\n        this.updateFinishedPromise();\r\n    }\r\n    /**\r\n     * This method uses the createdAt and resolvedAt to calculate the\r\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\r\n     * as the following frame would then be the first frame of the animation in\r\n     * progress, which would feel snappier.\r\n     *\r\n     * However, if there's a delay (main thread work) between the creation of\r\n     * the animation and the first commited frame, we prefer to use resolvedAt\r\n     * to avoid a sudden jump into the animation.\r\n     */\r\n    calcStartTime() {\r\n        if (!this.resolvedAt)\r\n            return this.createdAt;\r\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\r\n            ? this.resolvedAt\r\n            : this.createdAt;\r\n    }\r\n    /**\r\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\r\n     * this.resolved will synchronously flush all pending keyframe resolvers.\r\n     * This is a deoptimisation, but at its worst still batches read/writes.\r\n     */\r\n    get resolved() {\r\n        if (!this._resolved && !this.hasAttemptedResolve) {\r\n            flushKeyframeResolvers();\r\n        }\r\n        return this._resolved;\r\n    }\r\n    /**\r\n     * A method to be called when the keyframes resolver completes. This method\r\n     * will check if its possible to run the animation and, if not, skip it.\r\n     * Otherwise, it will call initPlayback on the implementing class.\r\n     */\r\n    onKeyframesResolved(keyframes, finalKeyframe) {\r\n        this.resolvedAt = time.now();\r\n        this.hasAttemptedResolve = true;\r\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\r\n        /**\r\n         * If we can't animate this value with the resolved keyframes\r\n         * then we should complete it immediately.\r\n         */\r\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\r\n            // Finish immediately\r\n            if (instantAnimationState.current || !delay) {\r\n                onUpdate &&\r\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.resolveFinishedPromise();\r\n                return;\r\n            }\r\n            // Finish after a delay\r\n            else {\r\n                this.options.duration = 0;\r\n            }\r\n        }\r\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\r\n        if (resolvedAnimation === false)\r\n            return;\r\n        this._resolved = {\r\n            keyframes,\r\n            finalKeyframe,\r\n            ...resolvedAnimation,\r\n        };\r\n        this.onPostResolved();\r\n    }\r\n    onPostResolved() { }\r\n    /**\r\n     * Allows the returned animation to be awaited or promise-chained. Currently\r\n     * resolves when the animation finishes at all but in a future update could/should\r\n     * reject if its cancels.\r\n     */\r\n    then(resolve, reject) {\r\n        return this.currentFinishedPromise.then(resolve, reject);\r\n    }\r\n    flatten() {\r\n        this.options.type = \"keyframes\";\r\n        this.options.ease = \"linear\";\r\n    }\r\n    updateFinishedPromise() {\r\n        this.currentFinishedPromise = new Promise((resolve) => {\r\n            this.resolveFinishedPromise = resolve;\r\n        });\r\n    }\r\n}\r\n\r\nexport { BaseAnimation };\r\n","import { isGenerator } from 'motion-dom';\r\nimport { warning } from 'motion-utils';\r\nimport { isAnimatable } from '../../utils/is-animatable.mjs';\r\n\r\nfunction hasKeyframesChanged(keyframes) {\r\n    const current = keyframes[0];\r\n    if (keyframes.length === 1)\r\n        return true;\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        if (keyframes[i] !== current)\r\n            return true;\r\n    }\r\n}\r\nfunction canAnimate(keyframes, name, type, velocity) {\r\n    /**\r\n     * Check if we're able to animate between the start and end keyframes,\r\n     * and throw a warning if we're attempting to animate between one that's\r\n     * animatable and another that isn't.\r\n     */\r\n    const originKeyframe = keyframes[0];\r\n    if (originKeyframe === null)\r\n        return false;\r\n    /**\r\n     * These aren't traditionally animatable but we do support them.\r\n     * In future we could look into making this more generic or replacing\r\n     * this function with mix() === mixImmediate\r\n     */\r\n    if (name === \"display\" || name === \"visibility\")\r\n        return true;\r\n    const targetKeyframe = keyframes[keyframes.length - 1];\r\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\r\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\r\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\r\n    // Always skip if any of these are true\r\n    if (!isOriginAnimatable || !isTargetAnimatable) {\r\n        return false;\r\n    }\r\n    return (hasKeyframesChanged(keyframes) ||\r\n        ((type === \"spring\" || isGenerator(type)) && velocity));\r\n}\r\n\r\nexport { canAnimate };\r\n","import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\r\n\r\nconst velocitySampleDuration = 5; // ms\r\nfunction calcGeneratorVelocity(resolveValue, t, current) {\r\n    const prevT = Math.max(t - velocitySampleDuration, 0);\r\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\r\n}\r\n\r\nexport { calcGeneratorVelocity };\r\n","const springDefaults = {\r\n    // Default spring physics\r\n    stiffness: 100,\r\n    damping: 10,\r\n    mass: 1.0,\r\n    velocity: 0.0,\r\n    // Default duration/bounce-based options\r\n    duration: 800, // in ms\r\n    bounce: 0.3,\r\n    visualDuration: 0.3, // in seconds\r\n    // Rest thresholds\r\n    restSpeed: {\r\n        granular: 0.01,\r\n        default: 2,\r\n    },\r\n    restDelta: {\r\n        granular: 0.005,\r\n        default: 0.5,\r\n    },\r\n    // Limits\r\n    minDuration: 0.01, // in seconds\r\n    maxDuration: 10.0, // in seconds\r\n    minDamping: 0.05,\r\n    maxDamping: 1,\r\n};\r\n\r\nexport { springDefaults };\r\n","import { warning, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\n\r\nconst safeMin = 0.001;\r\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\r\n    let envelope;\r\n    let derivative;\r\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\r\n    let dampingRatio = 1 - bounce;\r\n    /**\r\n     * Restrict dampingRatio and duration to within acceptable ranges.\r\n     */\r\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\r\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\r\n    if (dampingRatio < 1) {\r\n        /**\r\n         * Underdamped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const a = exponentialDecay - velocity;\r\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\r\n            const c = Math.exp(-delta);\r\n            return safeMin - (a / b) * c;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const d = delta * velocity + velocity;\r\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\r\n            const f = Math.exp(-delta);\r\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\r\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\r\n            return (factor * ((d - e) * f)) / g;\r\n        };\r\n    }\r\n    else {\r\n        /**\r\n         * Critically-damped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (undampedFreq - velocity) * duration + 1;\r\n            return -safeMin + a * b;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (velocity - undampedFreq) * (duration * duration);\r\n            return a * b;\r\n        };\r\n    }\r\n    const initialGuess = 5 / duration;\r\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\r\n    duration = secondsToMilliseconds(duration);\r\n    if (isNaN(undampedFreq)) {\r\n        return {\r\n            stiffness: springDefaults.stiffness,\r\n            damping: springDefaults.damping,\r\n            duration,\r\n        };\r\n    }\r\n    else {\r\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\r\n        return {\r\n            stiffness,\r\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\r\n            duration,\r\n        };\r\n    }\r\n}\r\nconst rootIterations = 12;\r\nfunction approximateRoot(envelope, derivative, initialGuess) {\r\n    let result = initialGuess;\r\n    for (let i = 1; i < rootIterations; i++) {\r\n        result = result - envelope(result) / derivative(result);\r\n    }\r\n    return result;\r\n}\r\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\r\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\r\n}\r\n\r\nexport { calcAngularFreq, findSpring };\r\n","import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\nimport { findSpring, calcAngularFreq } from './find.mjs';\r\n\r\nconst durationKeys = [\"duration\", \"bounce\"];\r\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\r\nfunction isSpringType(options, keys) {\r\n    return keys.some((key) => options[key] !== undefined);\r\n}\r\nfunction getSpringOptions(options) {\r\n    let springOptions = {\r\n        velocity: springDefaults.velocity,\r\n        stiffness: springDefaults.stiffness,\r\n        damping: springDefaults.damping,\r\n        mass: springDefaults.mass,\r\n        isResolvedFromDuration: false,\r\n        ...options,\r\n    };\r\n    // stiffness/damping/mass overrides duration/bounce\r\n    if (!isSpringType(options, physicsKeys) &&\r\n        isSpringType(options, durationKeys)) {\r\n        if (options.visualDuration) {\r\n            const visualDuration = options.visualDuration;\r\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\r\n            const stiffness = root * root;\r\n            const damping = 2 *\r\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\r\n                Math.sqrt(stiffness);\r\n            springOptions = {\r\n                ...springOptions,\r\n                mass: springDefaults.mass,\r\n                stiffness,\r\n                damping,\r\n            };\r\n        }\r\n        else {\r\n            const derived = findSpring(options);\r\n            springOptions = {\r\n                ...springOptions,\r\n                ...derived,\r\n                mass: springDefaults.mass,\r\n            };\r\n            springOptions.isResolvedFromDuration = true;\r\n        }\r\n    }\r\n    return springOptions;\r\n}\r\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\r\n    const options = typeof optionsOrVisualDuration !== \"object\"\r\n        ? {\r\n            visualDuration: optionsOrVisualDuration,\r\n            keyframes: [0, 1],\r\n            bounce,\r\n        }\r\n        : optionsOrVisualDuration;\r\n    let { restSpeed, restDelta } = options;\r\n    const origin = options.keyframes[0];\r\n    const target = options.keyframes[options.keyframes.length - 1];\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = { done: false, value: origin };\r\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\r\n        ...options,\r\n        velocity: -millisecondsToSeconds(options.velocity || 0),\r\n    });\r\n    const initialVelocity = velocity || 0.0;\r\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\r\n    const initialDelta = target - origin;\r\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\r\n    /**\r\n     * If we're working on a granular scale, use smaller defaults for determining\r\n     * when the spring is finished.\r\n     *\r\n     * These defaults have been selected emprically based on what strikes a good\r\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\r\n     */\r\n    const isGranularScale = Math.abs(initialDelta) < 5;\r\n    restSpeed || (restSpeed = isGranularScale\r\n        ? springDefaults.restSpeed.granular\r\n        : springDefaults.restSpeed.default);\r\n    restDelta || (restDelta = isGranularScale\r\n        ? springDefaults.restDelta.granular\r\n        : springDefaults.restDelta.default);\r\n    let resolveSpring;\r\n    if (dampingRatio < 1) {\r\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\r\n        // Underdamped spring\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            return (target -\r\n                envelope *\r\n                    (((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) /\r\n                        angularFreq) *\r\n                        Math.sin(angularFreq * t) +\r\n                        initialDelta * Math.cos(angularFreq * t)));\r\n        };\r\n    }\r\n    else if (dampingRatio === 1) {\r\n        // Critically damped spring\r\n        resolveSpring = (t) => target -\r\n            Math.exp(-undampedAngularFreq * t) *\r\n                (initialDelta +\r\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\r\n    }\r\n    else {\r\n        // Overdamped spring\r\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            // When performing sinh or cosh values can hit Infinity so we cap them here\r\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\r\n            return (target -\r\n                (envelope *\r\n                    ((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) *\r\n                        Math.sinh(freqForT) +\r\n                        dampedAngularFreq *\r\n                            initialDelta *\r\n                            Math.cosh(freqForT))) /\r\n                    dampedAngularFreq);\r\n        };\r\n    }\r\n    const generator = {\r\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\r\n        next: (t) => {\r\n            const current = resolveSpring(t);\r\n            if (!isResolvedFromDuration) {\r\n                let currentVelocity = 0.0;\r\n                /**\r\n                 * We only need to calculate velocity for under-damped springs\r\n                 * as over- and critically-damped springs can't overshoot, so\r\n                 * checking only for displacement is enough.\r\n                 */\r\n                if (dampingRatio < 1) {\r\n                    currentVelocity =\r\n                        t === 0\r\n                            ? secondsToMilliseconds(initialVelocity)\r\n                            : calcGeneratorVelocity(resolveSpring, t, current);\r\n                }\r\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\r\n                state.done =\r\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n            }\r\n            else {\r\n                state.done = t >= duration;\r\n            }\r\n            state.value = state.done ? target : current;\r\n            return state;\r\n        },\r\n        toString: () => {\r\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\r\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\r\n            return calculatedDuration + \"ms \" + easing;\r\n        },\r\n    };\r\n    return generator;\r\n}\r\n\r\nexport { spring };\r\n","import { spring } from './spring/index.mjs';\r\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\r\n\r\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\r\n    const origin = keyframes[0];\r\n    const state = {\r\n        done: false,\r\n        value: origin,\r\n    };\r\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\r\n    const nearestBoundary = (v) => {\r\n        if (min === undefined)\r\n            return max;\r\n        if (max === undefined)\r\n            return min;\r\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\r\n    };\r\n    let amplitude = power * velocity;\r\n    const ideal = origin + amplitude;\r\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\r\n    /**\r\n     * If the target has changed we need to re-calculate the amplitude, otherwise\r\n     * the animation will start from the wrong position.\r\n     */\r\n    if (target !== ideal)\r\n        amplitude = target - origin;\r\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\r\n    const calcLatest = (t) => target + calcDelta(t);\r\n    const applyFriction = (t) => {\r\n        const delta = calcDelta(t);\r\n        const latest = calcLatest(t);\r\n        state.done = Math.abs(delta) <= restDelta;\r\n        state.value = state.done ? target : latest;\r\n    };\r\n    /**\r\n     * Ideally this would resolve for t in a stateless way, we could\r\n     * do that by always precalculating the animation but as we know\r\n     * this will be done anyway we can assume that spring will\r\n     * be discovered during that.\r\n     */\r\n    let timeReachedBoundary;\r\n    let spring$1;\r\n    const checkCatchBoundary = (t) => {\r\n        if (!isOutOfBounds(state.value))\r\n            return;\r\n        timeReachedBoundary = t;\r\n        spring$1 = spring({\r\n            keyframes: [state.value, nearestBoundary(state.value)],\r\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\r\n            damping: bounceDamping,\r\n            stiffness: bounceStiffness,\r\n            restDelta,\r\n            restSpeed,\r\n        });\r\n    };\r\n    checkCatchBoundary(0);\r\n    return {\r\n        calculatedDuration: null,\r\n        next: (t) => {\r\n            /**\r\n             * We need to resolve the friction to figure out if we need a\r\n             * spring but we don't want to do this twice per frame. So here\r\n             * we flag if we updated for this frame and later if we did\r\n             * we can skip doing it again.\r\n             */\r\n            let hasUpdatedFrame = false;\r\n            if (!spring$1 && timeReachedBoundary === undefined) {\r\n                hasUpdatedFrame = true;\r\n                applyFriction(t);\r\n                checkCatchBoundary(t);\r\n            }\r\n            /**\r\n             * If we have a spring and the provided t is beyond the moment the friction\r\n             * animation crossed the min/max boundary, use the spring.\r\n             */\r\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\r\n                return spring$1.next(t - timeReachedBoundary);\r\n            }\r\n            else {\r\n                !hasUpdatedFrame && applyFriction(t);\r\n                return state;\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nexport { inertia };\r\n","import { easeInOut } from '../../easing/ease.mjs';\r\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\r\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\r\nimport { interpolate } from '../../utils/interpolate.mjs';\r\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\r\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\r\n\r\nfunction defaultEasing(values, easing) {\r\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\r\n}\r\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\r\n    /**\r\n     * Easing functions can be externally defined as strings. Here we convert them\r\n     * into actual functions.\r\n     */\r\n    const easingFunctions = isEasingArray(ease)\r\n        ? ease.map(easingDefinitionToFunction)\r\n        : easingDefinitionToFunction(ease);\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = {\r\n        done: false,\r\n        value: keyframeValues[0],\r\n    };\r\n    /**\r\n     * Create a times array based on the provided 0-1 offsets\r\n     */\r\n    const absoluteTimes = convertOffsetToTimes(\r\n    // Only use the provided offsets if they're the correct length\r\n    // TODO Maybe we should warn here if there's a length mismatch\r\n    times && times.length === keyframeValues.length\r\n        ? times\r\n        : defaultOffset(keyframeValues), duration);\r\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\r\n        ease: Array.isArray(easingFunctions)\r\n            ? easingFunctions\r\n            : defaultEasing(keyframeValues, easingFunctions),\r\n    });\r\n    return {\r\n        calculatedDuration: duration,\r\n        next: (t) => {\r\n            state.value = mapTimeToKeyframe(t);\r\n            state.done = t >= duration;\r\n            return state;\r\n        },\r\n    };\r\n}\r\n\r\nexport { defaultEasing, keyframes };\r\n","import { time } from '../../../frameloop/sync-time.mjs';\r\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\r\n\r\nconst frameloopDriver = (update) => {\r\n    const passTimestamp = ({ timestamp }) => update(timestamp);\r\n    return {\r\n        start: () => frame.update(passTimestamp, true),\r\n        stop: () => cancelFrame(passTimestamp),\r\n        /**\r\n         * If we're processing this frame we can use the\r\n         * framelocked timestamp to keep things in sync.\r\n         */\r\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\r\n    };\r\n};\r\n\r\nexport { frameloopDriver };\r\n","import { isGenerator, calcGeneratorDuration } from 'motion-dom';\r\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\r\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { mix } from '../../utils/mix/index.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { inertia } from '../generators/inertia.mjs';\r\nimport { keyframes } from '../generators/keyframes.mjs';\r\nimport { spring } from '../generators/spring/index.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\nconst generators = {\r\n    decay: inertia,\r\n    inertia,\r\n    tween: keyframes,\r\n    keyframes: keyframes,\r\n    spring,\r\n};\r\nconst percentToProgress = (percent) => percent / 100;\r\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\r\nclass MainThreadAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        /**\r\n         * The time at which the animation was paused.\r\n         */\r\n        this.holdTime = null;\r\n        /**\r\n         * The time at which the animation was cancelled.\r\n         */\r\n        this.cancelTime = null;\r\n        /**\r\n         * The current time of the animation.\r\n         */\r\n        this.currentTime = 0;\r\n        /**\r\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n         */\r\n        this.playbackSpeed = 1;\r\n        /**\r\n         * The state of the animation to apply when the animation is resolved. This\r\n         * allows calls to the public API to control the animation before it is resolved,\r\n         * without us having to resolve it first.\r\n         */\r\n        this.pendingPlayState = \"running\";\r\n        /**\r\n         * The time at which the animation was started.\r\n         */\r\n        this.startTime = null;\r\n        this.state = \"idle\";\r\n        /**\r\n         * This method is bound to the instance to fix a pattern where\r\n         * animation.stop is returned as a reference from a useEffect.\r\n         */\r\n        this.stop = () => {\r\n            this.resolver.cancel();\r\n            this.isStopped = true;\r\n            if (this.state === \"idle\")\r\n                return;\r\n            this.teardown();\r\n            const { onStop } = this.options;\r\n            onStop && onStop();\r\n        };\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\r\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\r\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    flatten() {\r\n        super.flatten();\r\n        // If we've already resolved the animation, re-initialise it\r\n        if (this._resolved) {\r\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\r\n        }\r\n    }\r\n    initPlayback(keyframes$1) {\r\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\r\n        const generatorFactory = isGenerator(type)\r\n            ? type\r\n            : generators[type] || keyframes;\r\n        /**\r\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n         * [0, 100] and then make a function that maps that to the actual keyframes.\r\n         *\r\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n         */\r\n        let mapPercentToKeyframes;\r\n        let mirroredGenerator;\r\n        if (generatorFactory !== keyframes &&\r\n            typeof keyframes$1[0] !== \"number\") {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\r\n            }\r\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\r\n            keyframes$1 = [0, 100];\r\n        }\r\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\r\n        /**\r\n         * If we have a mirror repeat type we need to create a second generator that outputs the\r\n         * mirrored (not reversed) animation and later ping pong between the two generators.\r\n         */\r\n        if (repeatType === \"mirror\") {\r\n            mirroredGenerator = generatorFactory({\r\n                ...this.options,\r\n                keyframes: [...keyframes$1].reverse(),\r\n                velocity: -velocity,\r\n            });\r\n        }\r\n        /**\r\n         * If duration is undefined and we have repeat options,\r\n         * we need to calculate a duration from the generator.\r\n         *\r\n         * We set it to the generator itself to cache the duration.\r\n         * Any timeline resolver will need to have already precalculated\r\n         * the duration by this step.\r\n         */\r\n        if (generator.calculatedDuration === null) {\r\n            generator.calculatedDuration = calcGeneratorDuration(generator);\r\n        }\r\n        const { calculatedDuration } = generator;\r\n        const resolvedDuration = calculatedDuration + repeatDelay;\r\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\r\n        return {\r\n            generator,\r\n            mirroredGenerator,\r\n            mapPercentToKeyframes,\r\n            calculatedDuration,\r\n            resolvedDuration,\r\n            totalDuration,\r\n        };\r\n    }\r\n    onPostResolved() {\r\n        const { autoplay = true } = this.options;\r\n        this.play();\r\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\r\n            this.pause();\r\n        }\r\n        else {\r\n            this.state = this.pendingPlayState;\r\n        }\r\n    }\r\n    tick(timestamp, sample = false) {\r\n        const { resolved } = this;\r\n        // If the animations has failed to resolve, return the final keyframe.\r\n        if (!resolved) {\r\n            const { keyframes } = this.options;\r\n            return { done: true, value: keyframes[keyframes.length - 1] };\r\n        }\r\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\r\n        if (this.startTime === null)\r\n            return generator.next(0);\r\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\r\n        /**\r\n         * requestAnimationFrame timestamps can come through as lower than\r\n         * the startTime as set by performance.now(). Here we prevent this,\r\n         * though in the future it could be possible to make setting startTime\r\n         * a pending operation that gets resolved here.\r\n         */\r\n        if (this.speed > 0) {\r\n            this.startTime = Math.min(this.startTime, timestamp);\r\n        }\r\n        else if (this.speed < 0) {\r\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\r\n        }\r\n        // Update currentTime\r\n        if (sample) {\r\n            this.currentTime = timestamp;\r\n        }\r\n        else if (this.holdTime !== null) {\r\n            this.currentTime = this.holdTime;\r\n        }\r\n        else {\r\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\r\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\r\n            // example.\r\n            this.currentTime =\r\n                Math.round(timestamp - this.startTime) * this.speed;\r\n        }\r\n        // Rebase on delay\r\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\r\n        const isInDelayPhase = this.speed >= 0\r\n            ? timeWithoutDelay < 0\r\n            : timeWithoutDelay > totalDuration;\r\n        this.currentTime = Math.max(timeWithoutDelay, 0);\r\n        // If this animation has finished, set the current time  to the total duration.\r\n        if (this.state === \"finished\" && this.holdTime === null) {\r\n            this.currentTime = totalDuration;\r\n        }\r\n        let elapsed = this.currentTime;\r\n        let frameGenerator = generator;\r\n        if (repeat) {\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            iterationProgress === 1 && currentIteration--;\r\n            currentIteration = Math.min(currentIteration, repeat + 1);\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const isOddIteration = Boolean(currentIteration % 2);\r\n            if (isOddIteration) {\r\n                if (repeatType === \"reverse\") {\r\n                    iterationProgress = 1 - iterationProgress;\r\n                    if (repeatDelay) {\r\n                        iterationProgress -= repeatDelay / resolvedDuration;\r\n                    }\r\n                }\r\n                else if (repeatType === \"mirror\") {\r\n                    frameGenerator = mirroredGenerator;\r\n                }\r\n            }\r\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\r\n        }\r\n        /**\r\n         * If we're in negative time, set state as the initial keyframe.\r\n         * This prevents delay: x, duration: 0 animations from finishing\r\n         * instantly.\r\n         */\r\n        const state = isInDelayPhase\r\n            ? { done: false, value: keyframes[0] }\r\n            : frameGenerator.next(elapsed);\r\n        if (mapPercentToKeyframes) {\r\n            state.value = mapPercentToKeyframes(state.value);\r\n        }\r\n        let { done } = state;\r\n        if (!isInDelayPhase && calculatedDuration !== null) {\r\n            done =\r\n                this.speed >= 0\r\n                    ? this.currentTime >= totalDuration\r\n                    : this.currentTime <= 0;\r\n        }\r\n        const isAnimationFinished = this.holdTime === null &&\r\n            (this.state === \"finished\" || (this.state === \"running\" && done));\r\n        if (isAnimationFinished && finalKeyframe !== undefined) {\r\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\r\n        }\r\n        if (onUpdate) {\r\n            onUpdate(state.value);\r\n        }\r\n        if (isAnimationFinished) {\r\n            this.finish();\r\n        }\r\n        return state;\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(this.currentTime);\r\n    }\r\n    set time(newTime) {\r\n        newTime = secondsToMilliseconds(newTime);\r\n        this.currentTime = newTime;\r\n        if (this.holdTime !== null || this.speed === 0) {\r\n            this.holdTime = newTime;\r\n        }\r\n        else if (this.driver) {\r\n            this.startTime = this.driver.now() - newTime / this.speed;\r\n        }\r\n    }\r\n    get speed() {\r\n        return this.playbackSpeed;\r\n    }\r\n    set speed(newSpeed) {\r\n        const hasChanged = this.playbackSpeed !== newSpeed;\r\n        this.playbackSpeed = newSpeed;\r\n        if (hasChanged) {\r\n            this.time = millisecondsToSeconds(this.currentTime);\r\n        }\r\n    }\r\n    play() {\r\n        if (!this.resolver.isScheduled) {\r\n            this.resolver.resume();\r\n        }\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"running\";\r\n            return;\r\n        }\r\n        if (this.isStopped)\r\n            return;\r\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\r\n        if (!this.driver) {\r\n            this.driver = driver((timestamp) => this.tick(timestamp));\r\n        }\r\n        onPlay && onPlay();\r\n        const now = this.driver.now();\r\n        if (this.holdTime !== null) {\r\n            this.startTime = now - this.holdTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        }\r\n        else if (this.state === \"finished\") {\r\n            this.startTime = now;\r\n        }\r\n        if (this.state === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        this.cancelTime = this.startTime;\r\n        this.holdTime = null;\r\n        /**\r\n         * Set playState to running only after we've used it in\r\n         * the previous logic.\r\n         */\r\n        this.state = \"running\";\r\n        this.driver.start();\r\n    }\r\n    pause() {\r\n        var _a;\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"paused\";\r\n            return;\r\n        }\r\n        this.state = \"paused\";\r\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    complete() {\r\n        if (this.state !== \"running\") {\r\n            this.play();\r\n        }\r\n        this.pendingPlayState = this.state = \"finished\";\r\n        this.holdTime = null;\r\n    }\r\n    finish() {\r\n        this.teardown();\r\n        this.state = \"finished\";\r\n        const { onComplete } = this.options;\r\n        onComplete && onComplete();\r\n    }\r\n    cancel() {\r\n        if (this.cancelTime !== null) {\r\n            this.tick(this.cancelTime);\r\n        }\r\n        this.teardown();\r\n        this.updateFinishedPromise();\r\n    }\r\n    teardown() {\r\n        this.state = \"idle\";\r\n        this.stopDriver();\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        this.startTime = this.cancelTime = null;\r\n        this.resolver.cancel();\r\n    }\r\n    stopDriver() {\r\n        if (!this.driver)\r\n            return;\r\n        this.driver.stop();\r\n        this.driver = undefined;\r\n    }\r\n    sample(time) {\r\n        this.startTime = 0;\r\n        return this.tick(time, true);\r\n    }\r\n}\r\n// Legacy interface\r\nfunction animateValue(options) {\r\n    return new MainThreadAnimation(options);\r\n}\r\n\r\nexport { MainThreadAnimation, animateValue };\r\n","const isNotNull = (value) => value !== null;\r\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\r\n    const resolvedKeyframes = keyframes.filter(isNotNull);\r\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\r\n        ? 0\r\n        : resolvedKeyframes.length - 1;\r\n    return !index || finalKeyframe === undefined\r\n        ? resolvedKeyframes[index]\r\n        : finalKeyframe;\r\n}\r\n\r\nexport { getFinalKeyframe };\r\n","/**\r\n * A list of values that can be hardware-accelerated.\r\n */\r\nconst acceleratedValues = new Set([\r\n    \"opacity\",\r\n    \"clipPath\",\r\n    \"filter\",\r\n    \"transform\",\r\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\r\n    // or until we implement support for linear() easing.\r\n    // \"background-color\"\r\n]);\r\n\r\nexport { acceleratedValues };\r\n","import { memo } from 'motion-utils';\r\n\r\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\r\n\r\nexport { supportsWaapi };\r\n","import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\r\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\r\nimport { anticipate } from '../../easing/anticipate.mjs';\r\nimport { backInOut } from '../../easing/back.mjs';\r\nimport { circInOut } from '../../easing/circ.mjs';\r\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\r\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\r\nimport { startWaapiAnimation } from './waapi/index.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\r\n\r\n/**\r\n * 10ms is chosen here as it strikes a balance between smooth\r\n * results (more than one keyframe per frame at 60fps) and\r\n * keyframe quantity.\r\n */\r\nconst sampleDelta = 10; //ms\r\n/**\r\n * Implement a practical max duration for keyframe generation\r\n * to prevent infinite loops\r\n */\r\nconst maxDuration = 20000;\r\n/**\r\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\r\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\r\n * handing off.\r\n */\r\nfunction requiresPregeneratedKeyframes(options) {\r\n    return (isGenerator(options.type) ||\r\n        options.type === \"spring\" ||\r\n        !isWaapiSupportedEasing(options.ease));\r\n}\r\nfunction pregenerateKeyframes(keyframes, options) {\r\n    /**\r\n     * Create a main-thread animation to pregenerate keyframes.\r\n     * We sample this at regular intervals to generate keyframes that we then\r\n     * linearly interpolate between.\r\n     */\r\n    const sampleAnimation = new MainThreadAnimation({\r\n        ...options,\r\n        keyframes,\r\n        repeat: 0,\r\n        delay: 0,\r\n        isGenerator: true,\r\n    });\r\n    let state = { done: false, value: keyframes[0] };\r\n    const pregeneratedKeyframes = [];\r\n    /**\r\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\r\n     * we're heading for an infinite loop.\r\n     */\r\n    let t = 0;\r\n    while (!state.done && t < maxDuration) {\r\n        state = sampleAnimation.sample(t);\r\n        pregeneratedKeyframes.push(state.value);\r\n        t += sampleDelta;\r\n    }\r\n    return {\r\n        times: undefined,\r\n        keyframes: pregeneratedKeyframes,\r\n        duration: t - sampleDelta,\r\n        ease: \"linear\",\r\n    };\r\n}\r\nconst unsupportedEasingFunctions = {\r\n    anticipate,\r\n    backInOut,\r\n    circInOut,\r\n};\r\nfunction isUnsupportedEase(key) {\r\n    return key in unsupportedEasingFunctions;\r\n}\r\nclass AcceleratedAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    initPlayback(keyframes, finalKeyframe) {\r\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\r\n        /**\r\n         * If element has since been unmounted, return false to indicate\r\n         * the animation failed to initialised.\r\n         */\r\n        if (!motionValue.owner || !motionValue.owner.current) {\r\n            return false;\r\n        }\r\n        /**\r\n         * If the user has provided an easing function name that isn't supported\r\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\r\n         * function. This will later get converted to a linear() easing function.\r\n         */\r\n        if (typeof ease === \"string\" &&\r\n            supportsLinearEasing() &&\r\n            isUnsupportedEase(ease)) {\r\n            ease = unsupportedEasingFunctions[ease];\r\n        }\r\n        /**\r\n         * If this animation needs pre-generated keyframes then generate.\r\n         */\r\n        if (requiresPregeneratedKeyframes(this.options)) {\r\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\r\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\r\n            keyframes = pregeneratedAnimation.keyframes;\r\n            // If this is a very short animation, ensure we have\r\n            // at least two keyframes to animate between as older browsers\r\n            // can't animate between a single keyframe.\r\n            if (keyframes.length === 1) {\r\n                keyframes[1] = keyframes[0];\r\n            }\r\n            duration = pregeneratedAnimation.duration;\r\n            times = pregeneratedAnimation.times;\r\n            ease = pregeneratedAnimation.ease;\r\n            type = \"keyframes\";\r\n        }\r\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\r\n        // Override the browser calculated startTime with one synchronised to other JS\r\n        // and WAAPI animations starting this event loop.\r\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        if (this.pendingTimeline) {\r\n            attachTimeline(animation, this.pendingTimeline);\r\n            this.pendingTimeline = undefined;\r\n        }\r\n        else {\r\n            /**\r\n             * Prefer the `onfinish` prop as it's more widely supported than\r\n             * the `finished` promise.\r\n             *\r\n             * Here, we synchronously set the provided MotionValue to the end\r\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\r\n             * be removed from the element which would then revert to its old styles.\r\n             */\r\n            animation.onfinish = () => {\r\n                const { onComplete } = this.options;\r\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.cancel();\r\n                this.resolveFinishedPromise();\r\n            };\r\n        }\r\n        return {\r\n            animation,\r\n            duration,\r\n            times,\r\n            type,\r\n            ease,\r\n            keyframes: keyframes,\r\n        };\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { duration } = resolved;\r\n        return millisecondsToSeconds(duration);\r\n    }\r\n    get time() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { animation } = resolved;\r\n        return millisecondsToSeconds(animation.currentTime || 0);\r\n    }\r\n    set time(newTime) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.currentTime = secondsToMilliseconds(newTime);\r\n    }\r\n    get speed() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 1;\r\n        const { animation } = resolved;\r\n        return animation.playbackRate;\r\n    }\r\n    set speed(newSpeed) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.playbackRate = newSpeed;\r\n    }\r\n    get state() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return \"idle\";\r\n        const { animation } = resolved;\r\n        return animation.playState;\r\n    }\r\n    get startTime() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return null;\r\n        const { animation } = resolved;\r\n        // Coerce to number as TypeScript incorrectly types this\r\n        // as CSSNumberish\r\n        return animation.startTime;\r\n    }\r\n    /**\r\n     * Replace the default DocumentTimeline with another AnimationTimeline.\r\n     * Currently used for scroll animations.\r\n     */\r\n    attachTimeline(timeline) {\r\n        if (!this._resolved) {\r\n            this.pendingTimeline = timeline;\r\n        }\r\n        else {\r\n            const { resolved } = this;\r\n            if (!resolved)\r\n                return noop;\r\n            const { animation } = resolved;\r\n            attachTimeline(animation, timeline);\r\n        }\r\n        return noop;\r\n    }\r\n    play() {\r\n        if (this.isStopped)\r\n            return;\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        if (animation.playState === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        animation.play();\r\n    }\r\n    pause() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.pause();\r\n    }\r\n    stop() {\r\n        this.resolver.cancel();\r\n        this.isStopped = true;\r\n        if (this.state === \"idle\")\r\n            return;\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation, keyframes, duration, type, ease, times } = resolved;\r\n        if (animation.playState === \"idle\" ||\r\n            animation.playState === \"finished\") {\r\n            return;\r\n        }\r\n        /**\r\n         * WAAPI doesn't natively have any interruption capabilities.\r\n         *\r\n         * Rather than read commited styles back out of the DOM, we can\r\n         * create a renderless JS animation and sample it twice to calculate\r\n         * its current value, \"previous\" value, and therefore allow\r\n         * Motion to calculate velocity for any subsequent animation.\r\n         */\r\n        if (this.time) {\r\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\r\n            const sampleAnimation = new MainThreadAnimation({\r\n                ...options,\r\n                keyframes,\r\n                duration,\r\n                type,\r\n                ease,\r\n                times,\r\n                isGenerator: true,\r\n            });\r\n            const sampleTime = secondsToMilliseconds(this.time);\r\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\r\n        }\r\n        const { onStop } = this.options;\r\n        onStop && onStop();\r\n        this.cancel();\r\n    }\r\n    complete() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.finish();\r\n    }\r\n    cancel() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.cancel();\r\n    }\r\n    static supports(options) {\r\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\r\n        if (!motionValue ||\r\n            !motionValue.owner ||\r\n            !(motionValue.owner.current instanceof HTMLElement)) {\r\n            return false;\r\n        }\r\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\r\n        return (supportsWaapi() &&\r\n            name &&\r\n            acceleratedValues.has(name) &&\r\n            /**\r\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\r\n             * no way to read the value from WAAPI every frame.\r\n             */\r\n            !onUpdate &&\r\n            !transformTemplate &&\r\n            !repeatDelay &&\r\n            repeatType !== \"mirror\" &&\r\n            damping !== 0 &&\r\n            type !== \"inertia\");\r\n    }\r\n}\r\n\r\nexport { AcceleratedAnimation };\r\n","import { mapEasingToNativeEasing } from 'motion-dom';\r\n\r\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times, } = {}) {\r\n    const keyframeOptions = { [valueName]: keyframes };\r\n    if (times)\r\n        keyframeOptions.offset = times;\r\n    const easing = mapEasingToNativeEasing(ease, duration);\r\n    /**\r\n     * If this is an easing array, apply to keyframes, not animation as a whole\r\n     */\r\n    if (Array.isArray(easing))\r\n        keyframeOptions.easing = easing;\r\n    return element.animate(keyframeOptions, {\r\n        delay,\r\n        duration,\r\n        easing: !Array.isArray(easing) ? easing : \"linear\",\r\n        fill: \"both\",\r\n        iterations: repeat + 1,\r\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\r\n    });\r\n}\r\n\r\nexport { startWaapiAnimation };\r\n","import { transformProps } from '../../render/html/utils/keys-transform.mjs';\r\n\r\nconst underDampedSpring = {\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restSpeed: 10,\r\n};\r\nconst criticallyDampedSpring = (target) => ({\r\n    type: \"spring\",\r\n    stiffness: 550,\r\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\r\n    restSpeed: 10,\r\n});\r\nconst keyframesTransition = {\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n};\r\n/**\r\n * Default easing curve is a slightly shallower version of\r\n * the default browser easing curve.\r\n */\r\nconst ease = {\r\n    type: \"keyframes\",\r\n    ease: [0.25, 0.1, 0.35, 1],\r\n    duration: 0.3,\r\n};\r\nconst getDefaultTransition = (valueKey, { keyframes }) => {\r\n    if (keyframes.length > 2) {\r\n        return keyframesTransition;\r\n    }\r\n    else if (transformProps.has(valueKey)) {\r\n        return valueKey.startsWith(\"scale\")\r\n            ? criticallyDampedSpring(keyframes[1])\r\n            : underDampedSpring;\r\n    }\r\n    return ease;\r\n};\r\n\r\nexport { getDefaultTransition };\r\n","import { getValueTransition, GroupPlaybackControls } from 'motion-dom';\r\nimport { secondsToMilliseconds } from 'motion-utils';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\r\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\r\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\r\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\r\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\r\n\r\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\r\n    const valueTransition = getValueTransition(transition, name) || {};\r\n    /**\r\n     * Most transition values are currently completely overwritten by value-specific\r\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\r\n     * delay actually does inherit from the root transition if not value-specific.\r\n     */\r\n    const delay = valueTransition.delay || transition.delay || 0;\r\n    /**\r\n     * Elapsed isn't a public transition option but can be passed through from\r\n     * optimized appear effects in milliseconds.\r\n     */\r\n    let { elapsed = 0 } = transition;\r\n    elapsed = elapsed - secondsToMilliseconds(delay);\r\n    let options = {\r\n        keyframes: Array.isArray(target) ? target : [null, target],\r\n        ease: \"easeOut\",\r\n        velocity: value.getVelocity(),\r\n        ...valueTransition,\r\n        delay: -elapsed,\r\n        onUpdate: (v) => {\r\n            value.set(v);\r\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\r\n        },\r\n        onComplete: () => {\r\n            onComplete();\r\n            valueTransition.onComplete && valueTransition.onComplete();\r\n        },\r\n        name,\r\n        motionValue: value,\r\n        element: isHandoff ? undefined : element,\r\n    };\r\n    /**\r\n     * If there's no transition defined for this value, we can generate\r\n     * unqiue transition settings for this value.\r\n     */\r\n    if (!isTransitionDefined(valueTransition)) {\r\n        options = {\r\n            ...options,\r\n            ...getDefaultTransition(name, options),\r\n        };\r\n    }\r\n    /**\r\n     * Both WAAPI and our internal animation functions use durations\r\n     * as defined by milliseconds, while our external API defines them\r\n     * as seconds.\r\n     */\r\n    if (options.duration) {\r\n        options.duration = secondsToMilliseconds(options.duration);\r\n    }\r\n    if (options.repeatDelay) {\r\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\r\n    }\r\n    if (options.from !== undefined) {\r\n        options.keyframes[0] = options.from;\r\n    }\r\n    let shouldSkip = false;\r\n    if (options.type === false ||\r\n        (options.duration === 0 && !options.repeatDelay)) {\r\n        options.duration = 0;\r\n        if (options.delay === 0) {\r\n            shouldSkip = true;\r\n        }\r\n    }\r\n    if (instantAnimationState.current ||\r\n        MotionGlobalConfig.skipAnimations) {\r\n        shouldSkip = true;\r\n        options.duration = 0;\r\n        options.delay = 0;\r\n    }\r\n    /**\r\n     * If we can or must skip creating the animation, and apply only\r\n     * the final keyframe, do so. We also check once keyframes are resolved but\r\n     * this early check prevents the need to create an animation at all.\r\n     */\r\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\r\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\r\n        if (finalKeyframe !== undefined) {\r\n            frame.update(() => {\r\n                options.onUpdate(finalKeyframe);\r\n                options.onComplete();\r\n            });\r\n            // We still want to return some animation controls here rather\r\n            // than returning undefined\r\n            return new GroupPlaybackControls([]);\r\n        }\r\n    }\r\n    /**\r\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\r\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\r\n     * optimised animation.\r\n     */\r\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\r\n        return new AcceleratedAnimation(options);\r\n    }\r\n    else {\r\n        return new MainThreadAnimation(options);\r\n    }\r\n};\r\n\r\nexport { animateMotionValue };\r\n","/**\r\n * Decide whether a transition is defined on a given Transition.\r\n * This filters out orchestration options and returns true\r\n * if any options are left.\r\n */\r\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\r\n    return !!Object.keys(transition).length;\r\n}\r\n\r\nexport { isTransitionDefined };\r\n","import { getValueTransition } from 'motion-dom';\r\nimport { positionalKeys } from '../../render/html/utils/keys-position.mjs';\r\nimport { setTarget } from '../../render/utils/setters.mjs';\r\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\r\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\r\nimport { animateMotionValue } from './motion-value.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\r\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\r\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\r\n    needsAnimating[key] = false;\r\n    return shouldBlock;\r\n}\r\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\r\n    var _a;\r\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\r\n    if (transitionOverride)\r\n        transition = transitionOverride;\r\n    const animations = [];\r\n    const animationTypeState = type &&\r\n        visualElement.animationState &&\r\n        visualElement.animationState.getState()[type];\r\n    for (const key in target) {\r\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\r\n        const valueTarget = target[key];\r\n        if (valueTarget === undefined ||\r\n            (animationTypeState &&\r\n                shouldBlockAnimation(animationTypeState, key))) {\r\n            continue;\r\n        }\r\n        const valueTransition = {\r\n            delay,\r\n            ...getValueTransition(transition || {}, key),\r\n        };\r\n        /**\r\n         * If this is the first time a value is being animated, check\r\n         * to see if we're handling off from an existing animation.\r\n         */\r\n        let isHandoff = false;\r\n        if (window.MotionHandoffAnimation) {\r\n            const appearId = getOptimisedAppearId(visualElement);\r\n            if (appearId) {\r\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\r\n                if (startTime !== null) {\r\n                    valueTransition.startTime = startTime;\r\n                    isHandoff = true;\r\n                }\r\n            }\r\n        }\r\n        addValueToWillChange(visualElement, key);\r\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\r\n            ? { type: false }\r\n            : valueTransition, visualElement, isHandoff));\r\n        const animation = value.animation;\r\n        if (animation) {\r\n            animations.push(animation);\r\n        }\r\n    }\r\n    if (transitionEnd) {\r\n        Promise.all(animations).then(() => {\r\n            frame.update(() => {\r\n                transitionEnd && setTarget(visualElement, transitionEnd);\r\n            });\r\n        });\r\n    }\r\n    return animations;\r\n}\r\n\r\nexport { animateTarget };\r\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\r\nimport { animateTarget } from './visual-element-target.mjs';\r\n\r\nfunction animateVariant(visualElement, variant, options = {}) {\r\n    var _a;\r\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\r\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\r\n        : undefined);\r\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\r\n    if (options.transitionOverride) {\r\n        transition = options.transitionOverride;\r\n    }\r\n    /**\r\n     * If we have a variant, create a callback that runs it as an animation.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getAnimation = resolved\r\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If we have children, create a callback that runs all their animations.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\r\n        ? (forwardDelay = 0) => {\r\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\r\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\r\n        }\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n     * this animation or all children animations before playing the other.\r\n     */\r\n    const { when } = transition;\r\n    if (when) {\r\n        const [first, last] = when === \"beforeChildren\"\r\n            ? [getAnimation, getChildAnimations]\r\n            : [getChildAnimations, getAnimation];\r\n        return first().then(() => last());\r\n    }\r\n    else {\r\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\r\n    }\r\n}\r\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\r\n    const animations = [];\r\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\r\n    const generateStaggerDuration = staggerDirection === 1\r\n        ? (i = 0) => i * staggerChildren\r\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\r\n    Array.from(visualElement.variantChildren)\r\n        .sort(sortByTreeOrder)\r\n        .forEach((child, i) => {\r\n        child.notify(\"AnimationStart\", variant);\r\n        animations.push(animateVariant(child, variant, {\r\n            ...options,\r\n            delay: delayChildren + generateStaggerDuration(i),\r\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\r\n    });\r\n    return Promise.all(animations);\r\n}\r\nfunction sortByTreeOrder(a, b) {\r\n    return a.sortNodePosition(b);\r\n}\r\n\r\nexport { animateVariant, sortByTreeOrder };\r\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\r\nimport { animateTarget } from './visual-element-target.mjs';\r\nimport { animateVariant } from './visual-element-variant.mjs';\r\n\r\nfunction animateVisualElement(visualElement, definition, options = {}) {\r\n    visualElement.notify(\"AnimationStart\", definition);\r\n    let animation;\r\n    if (Array.isArray(definition)) {\r\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\r\n        animation = Promise.all(animations);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        animation = animateVariant(visualElement, definition, options);\r\n    }\r\n    else {\r\n        const resolvedDefinition = typeof definition === \"function\"\r\n            ? resolveVariant(visualElement, definition, options.custom)\r\n            : definition;\r\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\r\n    }\r\n    return animation.then(() => {\r\n        visualElement.notify(\"AnimationComplete\", definition);\r\n    });\r\n}\r\n\r\nexport { animateVisualElement };\r\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\r\n\r\nconst optimizedAppearDataId = \"framerAppearId\";\r\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\r\n\r\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\r\n","import { optimizedAppearDataAttribute } from './data-id.mjs';\r\n\r\nfunction getOptimisedAppearId(visualElement) {\r\n    return visualElement.props[optimizedAppearDataAttribute];\r\n}\r\n\r\nexport { getOptimisedAppearId };\r\n","function isAnimationControls(v) {\r\n    return (v !== null &&\r\n        typeof v === \"object\" &&\r\n        typeof v.start === \"function\");\r\n}\r\n\r\nexport { isAnimationControls };\r\n","const isKeyframesTarget = (v) => {\r\n    return Array.isArray(v);\r\n};\r\n\r\nexport { isKeyframesTarget };\r\n","import { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\r\n\r\nfunction isNone(value) {\r\n    if (typeof value === \"number\") {\r\n        return value === 0;\r\n    }\r\n    else if (value !== null) {\r\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport { isNone };\r\n","import { useContext, useId, useEffect, useCallback } from 'react';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\n\r\n/**\r\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\r\n * to access information about whether it's still present in the React tree.\r\n *\r\n * ```jsx\r\n * import { usePresence } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const [isPresent, safeToRemove] = usePresence()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent && setTimeout(safeToRemove, 1000)\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\r\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\r\n *\r\n * @public\r\n */\r\nfunction usePresence(subscribe = true) {\r\n    const context = useContext(PresenceContext);\r\n    if (context === null)\r\n        return [true, null];\r\n    const { isPresent, onExitComplete, register } = context;\r\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\r\n    // either be null or non-null for the lifespan of the component.\r\n    const id = useId();\r\n    useEffect(() => {\r\n        if (subscribe)\r\n            register(id);\r\n    }, [subscribe]);\r\n    const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\r\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\r\n}\r\n/**\r\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\r\n * There is no `safeToRemove` function.\r\n *\r\n * ```jsx\r\n * import { useIsPresent } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const isPresent = useIsPresent()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent && console.log(\"I've been removed!\")\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useIsPresent() {\r\n    return isPresent(useContext(PresenceContext));\r\n}\r\nfunction isPresent(context) {\r\n    return context === null ? true : context.isPresent;\r\n}\r\n\r\nexport { isPresent, useIsPresent, usePresence };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst LayoutGroupContext = createContext({});\r\n\r\nexport { LayoutGroupContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst LazyContext = createContext({ strict: false });\r\n\r\nexport { LazyContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * @public\r\n */\r\nconst MotionConfigContext = createContext({\r\n    transformPagePoint: (p) => p,\r\n    isStatic: false,\r\n    reducedMotion: \"never\",\r\n});\r\n\r\nexport { MotionConfigContext };\r\n","import { useContext, useMemo } from 'react';\r\nimport { MotionContext } from './index.mjs';\r\nimport { getCurrentTreeVariants } from './utils.mjs';\r\n\r\nfunction useCreateMotionContext(props) {\r\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\r\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\r\n}\r\nfunction variantLabelsAsDependency(prop) {\r\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\r\n}\r\n\r\nexport { useCreateMotionContext };\r\n","import { isVariantLabel } from '../../render/utils/is-variant-label.mjs';\r\nimport { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';\r\n\r\nfunction getCurrentTreeVariants(props, context) {\r\n    if (isControllingVariants(props)) {\r\n        const { initial, animate } = props;\r\n        return {\r\n            initial: initial === false || isVariantLabel(initial)\r\n                ? initial\r\n                : undefined,\r\n            animate: isVariantLabel(animate) ? animate : undefined,\r\n        };\r\n    }\r\n    return props.inherit !== false ? context : {};\r\n}\r\n\r\nexport { getCurrentTreeVariants };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst MotionContext = createContext({});\r\n\r\nexport { MotionContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * @public\r\n */\r\nconst PresenceContext = createContext(null);\r\n\r\nexport { PresenceContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * Internal, exported only for usage in Framer\r\n */\r\nconst SwitchLayoutGroupContext = createContext({});\r\n\r\nexport { SwitchLayoutGroupContext };\r\n"],"names":["animateSingleValue","value","keyframes","options","motionValue$1","start","animation","isAnimatable","name","Array","isArray","complex","test","startsWith","BaseAnimation","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","this","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","finalKeyframe","velocity","onComplete","onUpdate","isGenerator","originKeyframe","targetKeyframe","length","isOriginAnimatable","isTargetAnimatable","current","i","hasKeyframesChanged","canAnimate","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise","calcGeneratorVelocity","resolveValue","t","prevT","Math","max","springDefaults","granular","default","safeMin","findSpring","bounce","mass","envelope","derivative","dampingRatio","clamp","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","e","pow","f","g","initialGuess","result","rootIterations","approximateRoot","isNaN","stiffness","damping","sqrt","durationKeys","physicsKeys","isSpringType","keys","some","key","undefined","spring","optionsOrVisualDuration","visualDuration","restSpeed","restDelta","origin","target","state","done","isResolvedFromDuration","springOptions","root","PI","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","abs","resolveSpring","angularFreq","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","nearestBoundary","v","amplitude","ideal","calcDelta","calcLatest","applyFriction","latest","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","defaultEasing","values","map","splice","keyframeValues","times","easingFunctions","absoluteTimes","mapTimeToKeyframe","interpolate","frameloopDriver","update","passTimestamp","timestamp","stop","isProcessing","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","super","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","resolver","cancel","teardown","onStop","motionValue","element","KeyframeResolver$1","KeyframeResolver","resolvedKeyframes","scheduleResolve","Object","assign","keyframes$1","generatorFactory","mapPercentToKeyframes","mirroredGenerator","pipe","mix","reverse","resolvedDuration","totalDuration","play","pause","tick","sample","speed","round","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","Boolean","isAnimationFinished","finish","time","newTime","driver","newSpeed","hasChanged","isScheduled","resume","onPlay","_a","complete","stopDriver","animateValue","isNotNull","getFinalKeyframe","filter","index","acceleratedValues","Set","supportsWaapi","hasOwnProperty","call","Element","prototype","unsupportedEasingFunctions","anticipate","backInOut","circInOut","AcceleratedAnimation","DOMKeyframesResolver","owner","pregeneratedAnimation","sampleAnimation","pregeneratedKeyframes","push","pregenerateKeyframes","valueName","keyframeOptions","offset","animate","fill","iterations","direction","startWaapiAnimation","pendingTimeline","onfinish","set","playbackRate","playState","attachTimeline","timeline","noop","sampleTime","setWithVelocity","supports","HTMLElement","transformTemplate","getProps","has","underDampedSpring","keyframesTransition","getDefaultTransition","valueKey","animateMotionValue","transition","isHandoff","valueTransition","getVelocity","when","_delay","delayChildren","staggerChildren","staggerDirection","from","isTransitionDefined","shouldSkip","skipAnimations","get","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","visualElement","targetAndTransition","transitionOverride","transitionEnd","animations","animationTypeState","animationState","getState","getValue","latestValues","valueTarget","window","MotionHandoffAnimation","appearId","shouldReduceMotion","all","animateVariant","variant","presenceContext","custom","getAnimation","getChildAnimations","variantChildren","size","forwardDelay","maxStaggerDuration","generateStaggerDuration","sort","sortByTreeOrder","forEach","child","notify","animateChildren","first","last","sortNodePosition","animateVisualElement","definition","resolvedDefinition","optimizedAppearDataAttribute","getOptimisedAppearId","props","isAnimationControls","isKeyframesTarget","isNone","usePresence","subscribe","context","useContext","isPresent","onExitComplete","register","id","useId","useEffect","safeToRemove","useCallback","LayoutGroupContext","createContext","LazyContext","strict","MotionConfigContext","transformPagePoint","p","isStatic","reducedMotion","useCreateMotionContext","initial","inherit","getCurrentTreeVariants","MotionContext","useMemo","variantLabelsAsDependency","prop","join","PresenceContext","SwitchLayoutGroupContext"],"sourceRoot":""}